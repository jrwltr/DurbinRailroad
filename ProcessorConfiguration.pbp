;=============================================================================
asm
    ERRORLEVEL -306  ;disable warning about crossing page boundary
endasm

;=============================================================================
#if __PROCESSOR__ = "16F18856"
#CONFIG
    __config _CONFIG1, _FEXTOSC_OFF & _RSTOSC_HFINTPLL & _CLKOUTEN_OFF & _CSWEN_OFF & _FCMEN_OFF
    __config _CONFIG2, _MCLRE_ON & _PWRTE_OFF & _LPBOREN_OFF & _BOREN_OFF & _BORV_LO & _ZCD_OFF & _PPS1WAY_OFF & _STVREN_ON & _DEBUG_OFF
    __config _CONFIG3, _WDTCPS_WDTCPS_11 & _WDTE_OFF & _WDTCWS_WDTCWS_7 & _WDTCCS_LFINTOSC
    __config _CONFIG4, _WRT_OFF & _SCANE_available & _LVP_OFF
    __config _CONFIG5, _CP_OFF & _CPD_OFF
#ENDCONFIG
#endif

;=============================================================================
#if __PROCESSOR__ = "16F19156"
#CONFIG
    __config _CONFIG1, _FEXTOSC_OFF & _RSTOSC_HFINTPLL & _CLKOUTEN_OFF & _VBATEN_OFF & _LCDPEN_OFF & _CSWEN_ON & _FCMEN_ON
    __config _CONFIG2, _MCLRE_ON & _PWRTE_PWRT_64 & _LPBOREN_OFF & _BOREN_SBOREN & _BORV_LO & _ZCD_OFF & _PPS1WAY_OFF & _STVREN_ON
    __config _CONFIG3, _WDTCPS_WDTCPS_31 & _WDTE_SWDTEN & _WDTCWS_WDTCWS_7 & _WDTCCS_LFINTOSC
    __config _CONFIG4, _BBSIZE_512 & _BBEN_OFF & _SAFEN_OFF & _WRTAPP_OFF & _WRTB_OFF & _WRTC_OFF & _WRTD_OFF & _WRTSAF_OFF & _LVP_OFF
    __config _CONFIG5, _CP_OFF

#ENDCONFIG
#endif

;=============================================================================
#if __PROCESSOR__ = "18F13K22"
#CONFIG
    CONFIG  FOSC = HS             ; HS oscillator
    CONFIG  PLLEN = OFF           ; PLL is under software control
    CONFIG  PCLKEN = ON           ; Primary clock enabled
    CONFIG  FCMEN = OFF           ; Fail-Safe Clock Monitor disabled
    CONFIG  IESO = OFF            ; Oscillator Switchover mode disabled
    CONFIG  PWRTEN = OFF          ; PWRT disabled
    CONFIG  BOREN = SBORDIS       ; Brown-out Reset enabled in hardware only (SBOREN is disabled)
    CONFIG  BORV = 19             ; VBOR set to 1.9 V nominal
    CONFIG  WDTEN = ON            ; WDT is always enabled. SWDTEN bit has no effect.
    CONFIG  WDTPS = 512           ; 1:512
    CONFIG  HFOFST = ON           ; HFINTOSC starts clocking the CPU without waiting for the oscillator to stablize.
    CONFIG  MCLRE = ON            ; MCLR pin enabled, RA3 input pin disabled
    CONFIG  STVREN = ON           ; Stack full/underflow will cause Reset
    CONFIG  LVP = OFF             ; Single-Supply ICSP disabled
    CONFIG  BBSIZ = OFF           ; 512W boot block size
    CONFIG  XINST = OFF           ; Instruction set extension and Indexed Addressing mode disabled (Legacy mode)
    CONFIG  DEBUG = OFF           ; Background debugger disabled, RA0 and RA1 configured as general purpose I/O pins
    CONFIG  CP0 = OFF             ; Block 0 not code-protected
    CONFIG  CP1 = OFF             ; Block 1 not code-protected
    CONFIG  CPB = OFF             ; Boot block not code-protected
    CONFIG  CPD = OFF             ; Data EEPROM not code-protected
    CONFIG  WRT0 = OFF            ; Block 0 not write-protected
    CONFIG  WRT1 = OFF            ; Block 1 not write-protected
    CONFIG  WRTC = OFF            ; Configuration registers not write-protected
    CONFIG  WRTB = OFF            ; Boot block not write-protected
    CONFIG  WRTD = OFF            ; Data EEPROM not write-protected
    CONFIG  EBTR0 = OFF           ; Block 0 not protected from table reads executed in other blocks
    CONFIG  EBTR1 = OFF           ; Block 1 not protected from table reads executed in other blocks
    CONFIG  EBTRB = OFF           ; Boot block not protected from table reads executed in other blocks
#ENDCONFIG
#endif

;=============================================================================
; DEFINEs:
define OSC 32
define I2C_SLOW 1   'Enables using 100KHz I2C device with OSC above 8MHz
define WRITE_INT 1  'Disables interrupts during EEPROM writes

;=============================================================================
; INITIALIZE REGISTERS:
#if __PROCESSOR__ = "18F13K22"
ANSEL  = %00000000    'Set all pins for digital operation
ANSELH = %00000000
OSCCON = %01110000    'Internal Osc set to 16MHz, clock determined by Config FOSC bits
#else
OSCCON1 = %00110000   'Internal Osc set to 16MHz, clock determined by Config FOSC bits
ANSELA = %00000000    'Set all pins for digital operation
ANSELB = %00000000
ANSELC = %00000000
#endif
#ifdef DO_DEVELOPMENT_BOARD
TRISA  = %10001111    'Set PORTA bits 0, 1, 2, 3, 7 as inputs, the rest as outputs
TRISB  = %01100000    'Set PORTB bits 5, 6 as inputs, the rest as outputs
TRISC  = %10100011    'Set PORTC bits 0, 1, 5, 7 as inputs, the rest as outputs
WPUA   = %10001111    'Set weak pullups on PORTA bits 0, 1, 2, 3 and 7, the rest as outputs
#else
TRISA  = %00100100    'Set PORTA bits 2, 5 as inputs, the rest as outputs
TRISB  = %00001111    'Set PORTB bits 0, 1, 2, 3 as inputs, the rest as outputs
TRISC  = %10110001    'Set PORTC bits 0, 4, 5, 7 as inputs, the rest as outputs
WPUA   = %00100100    'Set weak pullups on PORTA bits 2, 5, the rest as outputs
#endif

#if __PROCESSOR__ = "16F19156"
RB1PPS = $09    ; pin select RB1 is RB1
RB2PPS = $0a    ; pin select RB2 is RB2
RB3PPS = $0b    ; pin select RB3 is RB3
RC4PPS = $14    ; pin select RC4 is RC4
#endif

;=============================================================================
#ifdef DO_DEVELOPMENT_BOARD
    SCL1     var PORTC.3
    SDA1     var PORTC.4
    SCL2     var PORTA.4
    SDA2     var PORTA.5
#else
#ifdef DO_TURNTABLE
    SCL      var PORTB.1
    SDA      var PORTC.0
#endif
#ifdef DO_SWITCH_EXTENSION
    SCL1     var PORTB.4
    SDA1     var PORTC.6
    SCL2     var PORTC.0
    SDA2     var PORTC.1
#endif
#ifdef DO_SWITCH_CONTROLLER
    SDA1     var PORTA.0
    SCL1     var PORTA.1
    SDA2     var PORTA.3
    SCL2     var PORTA.4
    SCL3     var PORTB.4
    SDA3     var PORTB.5
#endif
#endif

#ifdef DO_SWITCHMOTOR
#ifdef DO_DEVELOPMENT_BOARD
    SW0_INTERFACE_I2C_CLK    var SCL1
    SW0_INTERFACE_I2C_DATA   var SDA1
#else
    SW0_INTERFACE_I2C_CLK    var SCL1
    SW0_INTERFACE_I2C_DATA   var SDA1
    SW1_INTERFACE_I2C_CLK    var SCL2
    SW1_INTERFACE_I2C_DATA   var SDA2
#endif
#endif

#ifdef DO_EEPROM
#ifdef DO_DEVELOPMENT_BOARD
    EEPROM_I2C_CLK          var SCL2
    EEPROM_I2C_DATA         var SDA2
#else
#ifdef DO_SWITCH_CONTROLLER
    EEPROM_I2C_CLK          var SCL3
    EEPROM_I2C_DATA         var SDA3
#endif
#ifdef DO_TURNTABLE
    EEPROM_I2C_CLK          var SCL
    EEPROM_I2C_DATA         var SDA
#endif
#endif
#endif

#ifdef DO_DISPLAY
#ifdef DO_DEVELOPMENT_BOARD
    DISPLAY_I2C_CLK         var SCL2
    DISPLAY_I2C_DATA        var SDA2
#else
#ifdef DO_SWITCH_CONTROLLER
    DISPLAY_I2C_CLK         var SCL3
    DISPLAY_I2C_DATA        var SDA3
#endif
#ifdef DO_TURNTABLE
    DISPLAY_I2C_CLK         var SCL
    DISPLAY_I2C_DATA        var SDA
#endif
#endif
#endif

;=============================================================================
#ifdef DO_OPERATE_PROGRAM
#ifdef DO_DEVELOPMENT_BOARD
    OperateProgramSwitch    var PORTC.1
#else
#ifdef DO_TURNTABLE
    OperateProgramSwitch    var PORTA.7
#endif
#ifdef DO_SWITCH_CONTROLLER
    OperateProgramSwitch    var PORTC.4
#endif
#endif
#endif

;=============================================================================
GLOBAL_INTERRUPT_ENABLE     var INTCON.7
PERIPHERAL_INTERRUPT_ENABLE var INTCON.6

;=============================================================================
#ifdef DO_EEPROM
EEPROM_BYTES    con 16384
#endif

;=============================================================================
#ifdef DO_DEVELOPMENT_BOARD
    ONBOARD_SWITCHES    var PORTA   ; low 4 bits
#else
#ifdef DO_TURNTABLE
    ONBOARD_SWITCHES    var PORTC   ; low 4 bits
#endif
#ifdef DO_SWITCH_CONTROLLER
    ONBOARD_SWITCHES    var PORTB   ; low 4 bits
#endif
#endif

;=============================================================================
#ifdef DO_DEVELOPMENT_BOARD
    LED_COUNT   con 4
    LED         var PORTB.1  ; treated as an array of bits LED[0]...LED[3]
#endif
#ifdef DO_SWITCH_EXTENSION
    LED_COUNT   con 1
    LED         var PORTA.5
#endif

;=============================================================================
#ifdef DO_SWITCHMOTOR
#ifdef DO_DEVELOPMENT_BOARD
    SWITCH_MOTOR_INTERFACE0_INTERRUPT  var PORTC.5
#else
#ifdef DO_SWITCH_EXTENSION
    SWITCH_MOTOR_INTERFACE0_INTERRUPT  var PORTA.2
    SWITCH_MOTOR_INTERFACE1_INTERRUPT  var PORTC.2
#endif
#ifdef DO_SWITCH_CONTROLLER
    SWITCH_MOTOR_INTERFACE0_INTERRUPT  var PORTA.2
    SWITCH_MOTOR_INTERFACE1_INTERRUPT  var PORTA.5
#endif
#endif
#endif

#ifdef DO_LOCONET
;=============================================================================
; Initialize UART for receiving Loconet data
;
#if __PROCESSOR__ = "18F13K22"
TXSTA = $20     ; TX9 = 0, TXEN = 1, SYNC = 0, BRGH = 0
BAUDCON = $10   ; SCKP = 1, BRG16 = 0   
    ;SCKP = 1 inverts transmit for loopback testing
SPBRGH = 0
SPBRG = 29      ; SP1RGH:SP1BRG = ((OSC * 1000000) / (64 * 16500)) - 1
                ;    OSC = 32
                ;    64 is divisor chosen by SYNC, BRGH and BRG16
                ;    16500 is the desired baud rate

while PIR1.5    ; read receive register until receive interrupt disappears
ASM
    movlb   15        ; set bank to 15
    movf    RCREG, W  ; W = RCREG
ENDASM
wend
PIR1.4 = 0      ; PIR3.TXIF = 0  clear serial port transmit interrupt flag
RCSTA.7 = 1     ; SPEN = 1       enable serial port
PIE1.5 = 1      ; RCIE = 1       enable receive interrupt
RCSTA.4 = 1     ; CREN = 1       enable the serial port receiver
#else
#if __PROCESSOR__ = "16F18856"
RXPPS = $17     ; pin select RX is RC7
#endif
#if __PROCESSOR__ = "16F19156"
RX1PPS = $17    ; pin select RX is RC7
#endif
RC6PPS = $10    ; pin select TX is RC6 as output
TX1STA = $20    ; TX9 = 0, TXEN = 1, SYNC = 0, BRGH = 0
BAUD1CON = $10  ; SCKP = 1, BRG16 = 0   
    ;SCKP = 1 inverts transmit for loopback testing
SP1BRGH = 0
SP1BRGL = 29    ; SP1RGH:SP1BRGL = ((OSC * 1000000) / (64 * 16500)) - 1
                ;    OSC = 32
                ;    64 is divisor chosen by SYNC, BRGH and BRG16
                ;    16500 is the desired baud rate

while PIR3.5    ; read receive register until receive interrupt disappears
ASM
    movlb   2         ; set bank to 2
    movf    RC1REG, W ; W = RC1REG
ENDASM
wend
PIR3.4 = 0      ; PIR3.TXIF = 0  clear serial port transmit interrupt flag
RC1STA.7 = 1    ; SPEN = 1       enable serial port
PIE3.5 = 1      ; RCIE = 1       enable receive interrupt
RC1STA.4 = 1    ; CREN = 1       enable the serial port receiver
#endif
#endif

;=============================================================================
#ifdef DO_SWITCHMOTOR
    PCF8574_I2C_ADDRESS     con $40 ; switch motor I/O expander
    PCF8574A_I2C_ADDRESS    con $70 ; switch motor I/O expander
#endif
#ifdef DO_DISPLAY
    DISPLAY_I2C_ADDRESS     con $4E
#endif
#ifdef DO_EEPROM
    EEPROM_I2C_ADDRESS      con $A0
#endif

;=============================================================================
; initialize timer 0 interrupts for interrupts about every 8 milliseconds
TMR0H = $ff     ; timer 0 8 bit comparator value
TMR0L = 0       ; timer 0 counter starts at zero
#if __PROCESSOR__ = "18F13K22"
T0CON = $47     ; T0CON.TMR0ON = 0 (disable), T0CON.T08BIT = 1 (8 bit counter), T0CON.T0PS<2:0> = 7 (1:256 prescale)
INTCON.2 = 0    ; INTCON.TMR0IF = 0  clear timer 0 interrupt flag
INTCON.5 = 1    ; INTCON.TMR0IE = 1  enable timer 0 interrupt
T0CON.7 = 1     ; T0CON.TMR0ON = 1 (enable), T0CON.T08BIT = 1 (8 bit counter), T0CON.T0PS<2:0> = 7 (1:256 prescale)
#else
T0CON1 = $68    ; T0CON1.TOCS<2:0> = HFINTOSC, T0CON1.T0ASYNC = 0, T0CON1.T0CKPS<3:0> = 8 (1:256 prescaler)
PIR0.5 = 0      ; PIR0.TMR0IF = 0  clear timer 0 interrupt flag
PIE0.5 = 1      ; PIE0.TMR0IE = 1  enable timer 0 interrupt
T0CON0 = $80    ; T0CON0.T0EN = 1  enable timer 0
#endif

#ifdef DO_TURNTABLE
;=============================================================================
#ifdef DO_DEVELOPMENT_BOARD
    TURNTABLE_XOR  var PORTA.6
    TURNTABLE_DIR1 var PORTC.2
    TURNTABLE_DIR2 var PORTB.0
#else
    TURNTABLE_DIR1 var PORTA.0
    TURNTABLE_DIR2 var PORTA.1
#endif

;=============================================================================
; initialize the DAC to control turntable speed

TURNTABLE_DAC   var DAC1CON1

DAC1CON1 = 0
DAC1CON0 = 0
DAC1CON0.4 = 1   ; DAC1CON0.DACOE2 = 0    DAC is output to DACOUT2 pin
DAC1CON0.7 = 1   ; DAC1CON0.DACEN = 1     enable DAC 

;=============================================================================
; Use timers 3 and 5 to generate an interrupt about every 1/2 second
; Timer 5 rolls over about every 65 milliseconds
; Timer 3 counts when timer 5 rolls over.  Timer 3 is set to -8 and interrupts when it rolls
; over to 0.  8 * 65 results in interrupts about every 520 milliseconds

; initialize timer 5
T5GCON = 0      ; disable Timer5 gate control
T5CLK = 1       ; Timer5 clock is Fosc/4
T5CON = $30     ; prescale = 1:8
; timer 5 now counts at Fosc/4/8 = 32/4/8 = 1Mhz, rolls over about every 65 milliseconds

; initialize timer 3
T3GCON = 0      ; disable Timer3 gate control
T3CLK = $0b     ; Timer3 clock is timer 5 rollover
T3CON = $00     ; prescale = 1:1
PIR4.2 = 0      ; PIR4.TMR3IF = 0  clear timer 3 interrupt flag
PIE4.2 = 1      ; PIE4.TMR3IE = 1  enable timer 3 interrupt

goto skip_funcs_1

ResetHalfSecondTimer:
    TMR3L = -8
    TMR3H = $ff
    return

StartHalfSecondTimer:
    TMR5L = 0       ; TMR5H:TMR5L = 0
    TMR5H = 0
    gosub ResetHalfSecondTimer
    T5CON.0 = 1 ; T5CON.ON = 1
    T3CON.0 = 1 ; T3CON.ON = 1
    return

StopHalfSecondTimer:
    T5CON.0 = 0 ; T5CON.ON = 0
    T3CON.0 = 0 ; T3CON.ON = 0
    return

skip_funcs_1:
;=============================================================================
; timer 1 is used in counter mode to count the edges from the turntable sensor

TURNTABLE_COUNTER_ENABLE            var T1CON.0 ; T1CON.TMR1ON
TURNTABLE_COUNTER_INTERRUPT_FLAG    var PIR4.0  ; PIR4.TMR1IF

; initialize timer 1
TRISC.0 = 1     ; RC0 is input
T1GCON = 0      ; disable Timer1 gate control
T1CON = $84     ; clock source is T1CKI, prescale = 1:1, don't synchronize

goto skip_funcs_2
StartTurntableCounter:
    ; start timer1 in counter mode
    TURNTABLE_COUNTER_ENABLE = 0
    TURNTABLE_COUNTER_INTERRUPT_FLAG = 0
    TMR1H = 0       ; TMR1H:TMR1L = 0
    TMR1L = 0       ;
    TURNTABLE_COUNTER_ENABLE = 1
    return

TTCounter var word[2]
T var word
ReadTurntableCounter:
    TTCounter[1] = 0
    do
        T.byte0 = TMR1L
        T.byte1 = TMR1H
        if TURNTABLE_COUNTER_INTERRUPT_FLAG then
            ;timer overflowed
            TTCounter[1] = 1
        endif
        ; if timer ticked while reading, read again
    loop until T.byte0 = TMR1L
    TTCounter[0] = T
    return
skip_funcs_2:

;=============================================================================

#endif

;=============================================================================

PERIPHERAL_INTERRUPT_ENABLE = 1

