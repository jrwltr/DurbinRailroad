;????fix fine movements with clockwise/counterclockwise keys, don't debounce key release?

;=============================================================================
TT_XOR  var PORTA.6
TT_DIR1 var PORTC.2
TT_DIR2 var PORTB.0

desired_tt_position     var word[2]
position_to_goto        var word[2]
last_switch_request     var word

save_operate_mode       var byte
save_desired_position   var word[2]

;=============================================================================

MAX_DAC_VALUE   con 31
RampDownCounts  var word[MAX_DAC_VALUE]

TT_ZERO_OFFSET_HI  con $0
TT_ZERO_OFFSET_LO  con $800

TT_MAX_POSITION_LO  con $86A0
TT_MAX_POSITION_HI  con $1

;=============================================================================
turntable_set_zero:
    current_tt_loc[0] = TT_ZERO_OFFSET_LO
    current_tt_loc[1] = TT_ZERO_OFFSET_HI
    goto turntable_ee_save_current_location

;=============================================================================
Timer1 var word[2]
T var word
read_timer1:
    Timer1[1] = 0
    do
        T.byte0 = TMR1L
        T.byte1 = TMR1H
        if PIR4.0 then
            ;timer overflowed
            Timer1[1] = 1
        endif
        ; if timer ticked while reading, read again
    loop until T.byte0 = TMR1L
    Timer1[0] = T
    return

;=============================================================================
turntable_stop_timer:
    T5CON.0 = 0 ; T5CON.ON = 0
    T3CON.0 = 0 ; T3CON.ON = 0
    return

;=============================================================================
CounterStop     var word[2]  ; number of counts before stopping timer
Clockwise       var bit

turntable_goto_position:
    if (current_tt_loc[0] = $ffff) and (current_tt_loc[0] = $ffff) then return

    long_minuend[0] = position_to_goto[0]
    long_minuend[1] = position_to_goto[1]
    long_subtrahend[0] = current_tt_loc[0]
    long_subtrahend[1] = current_tt_loc[1]
    gosub long_subtract

    if (long_result[0] = 0) and (long_result[1] = 0) then 
        ;position_to_goto = current_tt_loc
        return
    elseif long_result[1] & $8000 then
        ;position_to_goto < current_tt_loc

        long_minuend[0] = current_tt_loc[0]
        long_minuend[1] = current_tt_loc[1]
        long_subtrahend[0] = position_to_goto[0]
        long_subtrahend[1] = position_to_goto[1]
        gosub long_subtract

        Clockwise = 0
    else
        ;position_to_goto > current_tt_loc
        Clockwise = 1
    endif
    CounterStop[0] = long_result[0]
    CounterStop[1] = long_result[1]

    save_operate_mode = operate_mode
    operate_mode = MODE_MOVING
    gosub update_display

    ; start timer1 in counter mode
    T1CON.0 = 0     ; T1CON.TMR1ON = 0   disable timer 1
    PIR4.0 = 0      ; PIR4.TMR1IF = 0  turn off timer1 interrupt flag
    TMR1H = 0       ; TMR1H:TMR1L = 0
    TMR1L = 0       ;
    T1CON.0 = 1     ; T1CON.TMR1ON = 1   enable timer 1

    ; set the direction
    if Clockwise then
        TT_XOR  = 1
        TT_DIR1 = 1
        TT_DIR2 = 0
    else
        TT_XOR  = 0
        TT_DIR1 = 0
        TT_DIR2 = 1
    endif

    ; start turntable timer
    TMR5L = 0       ; TMR5H:TMR5L = 0
    TMR5H = 0
    TMR3L = -8
    TMR3H = $ff
    T5CON.0 = 1 ; T5CON.ON = 1
    T3CON.0 = 1 ; T3CON.ON = 1

    ; start the turntable
    DAC1CON1 = 1

    if (CounterStop[1] != 0) || (CounterStop[0] > RampDownCounts[0] + RampDownCounts[1]) then return

wait_until_done:
    gosub turntable_stop_timer
    long_minuend[0] = CounterStop[0]
    long_minuend[1] = CounterStop[1]
    do
        gosub read_timer1
        long_subtrahend[0] = Timer1[0]
        long_subtrahend[1] = Timer1[1]
        gosub long_subtract
    loop until ((long_result[0] = 0) and (long_result[1] = 0)) or (long_result[1] & $8000)
turntable_stop:
    gosub turntable_stop_timer

    operate_mode = save_operate_mode
    display_update_needed = 1
    if TT_DIR1 = 0 and TT_DIR2 = 0 then return  ; if already stopped return
    TT_DIR1 = 0     ; stop the turntable
    TT_DIR2 = 0     ;
    DAC1CON1 = 0

    pause 600       ; about 600 milliseconds before turntable stops moving at full speed
    T1CON.0 = 0     ; T1CON.TMR1ON = 0   disable timer 1

    gosub read_timer1
    if TT_XOR = 1 then
        ; clockwise, current_tt_loc = current_tt_loc + Timer1
        long_addend1[0] = current_tt_loc[0]
        long_addend1[1] = current_tt_loc[1]
        long_addend2[0] = Timer1[0]
        long_addend2[1] = Timer1[1]
        gosub long_add
    else
        ; counter clockwise, current_tt_loc = current_tt_loc - Timer1
        long_minuend[0] = current_tt_loc[0]
        long_minuend[1] = current_tt_loc[1]
        long_subtrahend[0] = Timer1[0]
        long_subtrahend[1] = Timer1[1]
        gosub long_subtract
    endif
    current_tt_loc[0] = long_result[0]
    current_tt_loc[1] = long_result[1]
    goto turntable_ee_save_current_location

;=============================================================================
turntable_timer_expired:
    ; reset timer 3
    TMR3L = -8
    TMR3H = $ff

    gosub read_timer1
    long_minuend[0] = CounterStop[0]
    long_minuend[1] = CounterStop[1]
    long_subtrahend[0] = Timer1[0]
    long_subtrahend[1] = Timer1[1]
    gosub long_subtract
    long_minuend[0] = long_result[0]
    long_minuend[1] = long_result[1]
    ;long_minuend contains the number of counts left until stop

    ExpectedCountsAtNextSpeed   var word
    if (DAC1CON1 < MAX_DAC_VALUE) then
        ExpectedCountsAtNextSpeed = RampDownCounts[DAC1CON1  ] - RampDownCounts[DAC1CON1-1]
    else
        ExpectedCountsAtNextSpeed = RampDownCounts[MAX_DAC_VALUE-1] - RampDownCounts[MAX_DAC_VALUE-2]
    endif
    long_subtrahend[0] = RampDownCounts[DAC1CON1-1] + ExpectedCountsAtNextSpeed
    long_subtrahend[1] = 0
    gosub long_subtract

    ;(CounterStop - Timer1) is the number of counts left before stopping
    ;(RampDownCounts[DAC1CON1-1] + ExpectedCountsAtNextSpeed)) is the number of counts it will
    ;take to stop if we speed up to the next DAC value or hold at max speed
    ;if ((CounterStop - Timer1) < (RampDownCounts[DAC1CON1-1] + ExpectedCountsAtNextSpeed)) then
    if (long_result[1] & $8000) then
        do
            DAC1CON1 = DAC1CON1 - 1
        loop until (DAC1CON1 = 1) or ((long_minuend[1] = 0) and (long_minuend[0] > RampDownCounts[DAC1CON1-1]))
    else
        if (DAC1CON1 < MAX_DAC_VALUE) then
            DAC1CON1 = DAC1CON1 + 1
        endif
    endif
    if DAC1CON1 = 1 then
        gosub wait_until_done
    endif
    return

;=============================================================================
turntable_counterclockwise:
    ; goto zero or until key is released
    position_to_goto[0] = TT_ZERO_OFFSET_LO
    position_to_goto[1] = TT_ZERO_OFFSET_HI
    goto turntable_goto_position

;=============================================================================
turntable_clockwise:
    ; goto max or until key is released
    long_addend1[0] = TT_ZERO_OFFSET_LO
    long_addend1[1] = TT_ZERO_OFFSET_HI
    long_addend2[0] = TT_MAX_POSITION_LO
    long_addend2[1] = TT_MAX_POSITION_HI
    gosub long_add
    position_to_goto[0] = long_result[0]
    position_to_goto[1] = long_result[1]
    goto turntable_goto_position

;=============================================================================
turntable_next_location:
    if (loconet_switch = $ffff) or (tt_stop = MAX_TT_STOPS - 1) then return
    tt_stop = tt_stop + 1
    gosub turntable_ee_read_stop
    if tt_ee_switch != $ffff then
        loconet_switch = tt_ee_switch
        last_switch_request = tt_ee_switch
        desired_tt_position[0] = tt_ee_position[0]
        desired_tt_position[1] = tt_ee_position[1]
    else
        tt_stop = tt_stop - 1
    endif
    return

;=============================================================================
turntable_previous_location:
    if (loconet_switch = $ffff) or (tt_stop = 0) then return
    tt_stop = tt_stop - 1
    gosub turntable_ee_read_stop
    loconet_switch = tt_ee_switch
    last_switch_request = tt_ee_switch
    desired_tt_position[0] = tt_ee_position[0]
    desired_tt_position[1] = tt_ee_position[1]
    return

;=============================================================================
handle_switch_request:
    gosub turntable_ee_look_up_loconet_switch
    if (tt_ee_switch = loconet_switch) then
        desired_tt_position[0] = tt_ee_position[0]
        desired_tt_position[1] = tt_ee_position[1]
        ; loconet_switch found in translate table
        last_switch_request = loconet_switch
        if operate_mode = MODE_PROGRAM then return
    else
        ; loconet_switch not found in translate table
        if operate_mode = MODE_OPERATE then 
            loconet_switch = last_switch_request
        else
            desired_tt_position[0] = $ffff
            desired_tt_position[1] = $ffff
        endif
        return
    endif
    position_to_goto[0] = desired_tt_position[0]
    position_to_goto[1] = desired_tt_position[1]
    goto turntable_goto_position

;=============================================================================
turntable_set_translation:
    if (loconet_switch = $ffff) or ((current_tt_loc[0] = $ffff) and (current_tt_loc[1] = $ffff)) then return
    gosub turntable_ee_look_up_loconet_switch
    if (tt_stop = MAX_TT_STOPS) then
        ; EEPROM is full
        return
    endif
    desired_tt_position[0] = current_tt_loc[0]
    desired_tt_position[1] = current_tt_loc[1]
    tt_ee_switch = loconet_switch
    tt_ee_position[0] = current_tt_loc[0]
    tt_ee_position[1] = current_tt_loc[1]
    goto turntable_ee_write_stop

;=============================================================================
turntable_initialize:
    TT_DIR1 = 0
    TT_DIR2 = 0
    DAC1CON1 = 0
    DAC1CON0 = 0
    DAC1CON0.4 = 1   ; DAC1CON0.DACOE2 = 0    DAC is output to DACOUT2 pin
    DAC1CON0.7 = 1   ; DAC1CON0.DACEN = 1     enable DAC 

    RampDownCounts[ 0] = 10 
    RampDownCounts[ 1] = 44 
    RampDownCounts[ 2] = 108 
    RampDownCounts[ 3] = 201 
    RampDownCounts[ 4] = 326 
    RampDownCounts[ 5] = 482 
    RampDownCounts[ 6] = 670 
    RampDownCounts[ 7] = 888 
    RampDownCounts[ 8] = 1137 
    RampDownCounts[ 9] = 1419 
    RampDownCounts[10] = 1730 
    RampDownCounts[11] = 2071 
    RampDownCounts[12] = 2444 
    RampDownCounts[13] = 2848 
    RampDownCounts[14] = 3285 
    RampDownCounts[15] = 3757 
    RampDownCounts[16] = 4259 
    RampDownCounts[17] = 4793 
    RampDownCounts[18] = 5362 
    RampDownCounts[19] = 5966 
    RampDownCounts[20] = 6601 
    RampDownCounts[21] = 7270 
    RampDownCounts[22] = 7974 
    RampDownCounts[23] = 8714 
    RampDownCounts[24] = 9486 
    RampDownCounts[25] = 10297 
    RampDownCounts[26] = 11143 
    RampDownCounts[27] = 12025 
    RampDownCounts[28] = 12948 
    RampDownCounts[29] = 13906 
    RampDownCounts[30] = 14906 

    ; initialize timer 1, timer 1 is used as a counter to count the edges from the turntable sensor
    TRISC.0 = 1     ; RC0 is input
    T1GCON = 0      ; disable Timer1 gate control
    T1CON = $84     ; clock source is T1CKI, prescale = 1:1, don't synchronize

    ; use timers 3 and 5 to generate an interrupt about every 1/2 second
    ; Timer 5 rolls over about every 65 milliseconds
    ; Timer 3 counts when timer 5 rolls over.  Timer 3 is set to -8 and interrupts when it rolls
    ; over to 0.  8 * 65 results in interrupts about every 520 milliseconds

    ; initialize timer 5
    T5GCON = 0      ; disable Timer5 gate control
    T5CLK = 1       ; Timer5 clock is Fosc/4
    T5CON = $30     ; prescale = 1:8
    ; timer 5 now counts at Fosc/4/8 = 32/4/8 = 1Mhz, rolls over about every 65 milliseconds

    ; initialize timer 3
    T3GCON = 0      ; disable Timer3 gate control
    T3CLK = $0b     ; Timer3 clock is timer 5 rollover
    T3CON = $00     ; prescale = 1:1

    last_switch_request = $ffff
    desired_tt_position[0] = $ffff
    desired_tt_position[1] = $ffff

    gosub turntable_ee_read_current_location

    ; try to find the current location in the translation table
    for tt_stop = 0 to MAX_TT_STOPS - 1
        gosub turntable_ee_read_stop
        if (tt_ee_switch = $ffff) then 
            tt_stop = MAX_TT_STOPS
            exit
        endif
        if (tt_ee_position[0] = current_tt_loc[0]) and (tt_ee_position[1] = current_tt_loc[1]) then
            exit
        endif
    next tt_stop 
    if  (tt_stop = MAX_TT_STOPS) then
        ; current location not found in translate table
        ; use the first entry in the translate table if it exists
        tt_stop = 0
        gosub turntable_ee_read_stop
    endif
    if tt_ee_switch != $ffff then
        loconet_switch = tt_ee_switch 
        desired_tt_position[0] = tt_ee_position[0]
        desired_tt_position[1] = tt_ee_position[1]
    endif
    last_switch_request = loconet_switch
    return

;=============================================================================

