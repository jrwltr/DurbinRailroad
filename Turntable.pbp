;????fix fine movements with clockwise/counterclockwise keys

;=============================================================================
TT_XOR  var PORTA.6
TT_DIR1 var PORTC.2
TT_DIR2 var PORTB.0

desired_tt_position var word[2]
last_switch_request var word

save_operate_mode   var byte

;=============================================================================

MAX_DAC_VALUE   con 31
CountsPerSecond     var word[MAX_DAC_VALUE-1]
CumulativeCounts    var word[MAX_DAC_VALUE-1]
MaxSpeedIndex       var byte
HoldTimer3Value     var word
kk                  var byte

RampState           var byte
    RAMP_UP_ONLY    con 0
    RAMP_UP         con 1
    RAMP_HOLD       con 2
    RAMP_DOWN       con 3

;=============================================================================
TT_ZERO_OFFSET_HI  con $0
TT_ZERO_OFFSET_LO  con $800
turntable_set_zero:
    current_tt_loc[0] = TT_ZERO_OFFSET_LO
    current_tt_loc[1] = TT_ZERO_OFFSET_HI
    goto turntable_ee_save_current_location

;=============================================================================
Timer1 var word[2]
T var word
read_timer1:
    Timer1[1] = 0
    do
        T.byte0 = TMR1L
        T.byte1 = TMR1H
        if PIR1.0 then
            ;timer overflowed
            Timer1[1] = 1
        endif
        ; if timer ticked while reading, read again
    loop until T.byte0 = TMR1L
    Timer1[0] = T
    return

;=============================================================================
start_timer1:
    ; start timer1 in counter mode
    T1CON.0 = 0     ; T1CON.TMR1ON = 0   disable timer 1
    PIR1.0 = 0      ; PIR1.TMR1IF = 0  turn off timer1 interrupt flag
    TMR1H = 0       ; TMR1H:TMR1L = 0
    TMR1L = 0       ;
    T1CON.0 = 1     ; T1CON.TMR1ON = 1   enable timer 1
    return

;=============================================================================
turntable_stop_timer:
    T5CON.0 = 0 ; T5CON.ON = 0
    T3CON.0 = 0 ; T3CON.ON = 0
    return

;=============================================================================
CounterStop     var word[2]  ; number of counts before stopping timer
Clockwise       var bit

turntable_goto_position:
    if (current_tt_loc[0] = $ffff) and (current_tt_loc[0] = $ffff) then return

    long_minuend[0] = desired_tt_position[0]
    long_minuend[1] = desired_tt_position[1]
    long_subtrahend[0] = current_tt_loc[0]
    long_subtrahend[1] = current_tt_loc[1]
    gosub long_subtract

    if (long_result[0] = 0) and (long_result[1] = 0) then 
        ;desired_tt_position = current_tt_loc
        return
    elseif long_result[1] & $8000 then
        ;desired_tt_position < current_tt_loc

        long_minuend[0] = current_tt_loc[0]
        long_minuend[1] = current_tt_loc[1]
        long_subtrahend[0] = desired_tt_position[0]
        long_subtrahend[1] = desired_tt_position[1]
        gosub long_subtract

        Clockwise = 0
    else
        ;desired_tt_position > current_tt_loc
        Clockwise = 1
    endif
    CounterStop[0] = long_result[0]
    CounterStop[1] = long_result[1]

    for MaxSpeedIndex = MAX_DAC_VALUE-2 to 1 step -1
        long_minuend[0] = CumulativeCounts[MaxSpeedIndex]
        long_minuend[1] = 0
        long_subtrahend[0] = CounterStop[0]
        long_subtrahend[1] = CounterStop[1]
        gosub long_subtract
        ; if CumulativeCounts[MaxSpeedIndex] <= CounterStop then exit
        if long_result[1] & $8000 then exit
    next MaxSpeedIndex

    ; HoldTimer3Value = -int((16 * (CounterStop-CumulativeCounts[MaxSpeedIndex]))/CountsPerSecond[MaxSpeedIndex])
    long_minuend[0] = CounterStop[0]
    long_minuend[1] = CounterStop[1]
    long_subtrahend[0] = CumulativeCounts[MaxSpeedIndex-1]
    long_subtrahend[1] = 0
    gosub long_subtract
    long_multiplicand[0] = long_result[0]
    long_multiplicand[1] = long_result[1]
    long_multiplier = 16
    gosub long_multiply
    long_dividend[0] = long_result[0]
    long_dividend[1] = long_result[1]
    long_divisor[0] = CountsPerSecond[MaxSpeedIndex]
    long_divisor[1] = 0
    gosub long_divide
    HoldTimer3Value = -long_result[0]

    ; start the turntable
    if Clockwise then
        gosub turntable_clockwise
    else
        gosub turntable_counterclockwise
    endif
    
    RampState = RAMP_UP;

    if MaxSpeedIndex != 0 then return
wait_until_done:
    gosub turntable_stop_timer
    long_minuend[0] = CounterStop[0]
    long_minuend[1] = CounterStop[1]
    do
        gosub read_timer1
        long_subtrahend[0] = Timer1[0]
        long_subtrahend[1] = Timer1[1]
        gosub long_subtract
    loop until ((long_result[0] = 0) and (long_result[1] = 0)) or (long_result[1] & $8000)
turntable_stop:
    gosub turntable_stop_timer

    operate_mode = save_operate_mode
    display_update_needed = 1
    if TT_DIR1 = 0 and TT_DIR2 = 0 then return  ; if already stopped return
    TT_DIR1 = 0     ; stop the turntable
    TT_DIR2 = 0     ;
    DAC1CON1 = 0

    pause 600       ; about 600 milliseconds before turntable stops moving at full speed
    T1CON.0 = 0     ; T1CON.TMR1ON = 0   disable timer 1

    gosub read_timer1
    if TT_XOR = 1 then
        ; clockwise, current_tt_loc = current_tt_loc + Timer1
        long_addend1[0] = current_tt_loc[0]
        long_addend1[1] = current_tt_loc[1]
        long_addend2[0] = Timer1[0]
        long_addend2[1] = Timer1[1]
        gosub long_add
    else
        ; counter clockwise, current_tt_loc = current_tt_loc - Timer1
        long_minuend[0] = current_tt_loc[0]
        long_minuend[1] = current_tt_loc[1]
        long_subtrahend[0] = Timer1[0]
        long_subtrahend[1] = Timer1[1]
        gosub long_subtract
    endif
    current_tt_loc[0] = long_result[0]
    current_tt_loc[1] = long_result[1]
    goto turntable_ee_save_current_location

;=============================================================================
turntable_timer_expired:
    ; reset timer 3
    TMR3L = -8
    TMR3H = $ff

    if RampState = RAMP_UP_ONLY then
        if DAC1CON1 < MAX_DAC_VALUE then
            DAC1CON1 = DAC1CON1 + 1
        endif
    elseif RampState = RAMP_UP then
        if DAC1CON1 < MaxSpeedIndex then DAC1CON1 = DAC1CON1 + 1
        if DAC1CON1 = MaxSpeedIndex then
            if HoldTimer3Value then
                RampState = RAMP_HOLD;
                TMR3L = HoldTimer3Value.byte0
                TMR3H = HoldTimer3Value.byte1
            else
                RampState = RAMP_DOWN;
            endif
        endif
    elseif (RampState = RAMP_HOLD) or (RampState = RAMP_DOWN) then
        RampState = RAMP_DOWN;
        if DAC1CON1 != 1 then DAC1CON1 = DAC1CON1 - 1
        if DAC1CON1 = 1 then
            gosub wait_until_done
        endif
    endif
    return

;=============================================================================
turntable_counterclockwise:
    gosub start_timer1
    TT_XOR  = 0
    TT_DIR1 = 0
    TT_DIR2 = 1
    goto turntable_start_dac

turntable_clockwise:
    gosub start_timer1
    TT_XOR  = 1
    TT_DIR1 = 1
    TT_DIR2 = 0
turntable_start_dac:
    save_operate_mode = operate_mode
    operate_mode = MODE_MOVING
    gosub update_display

    DAC1CON1 = 1

    ; start turntable timer
    TMR5L = 0       ; TMR5H:TMR5L = 0
    TMR5H = 0
    TMR3L = -8
    TMR3H = $ff
    T5CON.0 = 1 ; T5CON.ON = 1
    T3CON.0 = 1 ; T3CON.ON = 1

    RampState = RAMP_UP_ONLY
    return

;=============================================================================
turntable_next_location:
    if (loconet_switch = $ffff) or (tt_stop = MAX_TT_STOPS - 1) then return
    tt_stop = tt_stop + 1
    gosub turntable_ee_read_stop
    if tt_ee_switch != $ffff then
        loconet_switch = tt_ee_switch
        last_switch_request = tt_ee_switch
        desired_tt_position[0] = tt_ee_position[0]
        desired_tt_position[1] = tt_ee_position[1]
    else
        tt_stop = tt_stop - 1
    endif
    return

;=============================================================================
turntable_previous_location:
    if (loconet_switch = $ffff) or (tt_stop = 0) then return
    tt_stop = tt_stop - 1
    gosub turntable_ee_read_stop
    loconet_switch = tt_ee_switch
    last_switch_request = tt_ee_switch
    desired_tt_position[0] = tt_ee_position[0]
    desired_tt_position[1] = tt_ee_position[1]
    return

;=============================================================================
handle_switch_request:
    gosub turntable_ee_look_up_loconet_switch
    if (tt_ee_switch = loconet_switch) then
        desired_tt_position[0] = tt_ee_position[0]
        desired_tt_position[1] = tt_ee_position[1]
        ; loconet_switch found in translate table
        last_switch_request = loconet_switch
        if operate_mode = MODE_PROGRAM then return
    else
        ; loconet_switch not found in translate table
        if operate_mode = MODE_OPERATE then 
            loconet_switch = last_switch_request
        else
            desired_tt_position[0] = $ffff
            desired_tt_position[1] = $ffff
        endif
        return
    endif
    goto turntable_goto_position

;=============================================================================
turntable_set_translation:
    if (loconet_switch = $ffff) or ((current_tt_loc[0] = $ffff) and (current_tt_loc[1] = $ffff)) then return
    gosub turntable_ee_look_up_loconet_switch
    if (tt_stop = MAX_TT_STOPS) then
        ; EEPROM is full
        return
    endif
    desired_tt_position[0] = current_tt_loc[0]
    desired_tt_position[1] = current_tt_loc[1]
    tt_ee_switch = loconet_switch
    tt_ee_position[0] = current_tt_loc[0]
    tt_ee_position[1] = current_tt_loc[1]
    goto turntable_ee_write_stop

;=============================================================================
turntable_initialize:
    TT_DIR1 = 0
    TT_DIR2 = 0
    DAC1CON1 = 0
    DAC1CON0 = 0
    DAC1CON0.4 = 1   ; DAC1CON0.DACOE2 = 0    DAC is output to DACOUT2 pin
    DAC1CON0.7 = 1   ; DAC1CON0.DACEN = 1     enable DAC 

    CountsPerSecond[ 0] = 20
    CountsPerSecond[ 1] = 68
    CountsPerSecond[ 2] = 128
    CountsPerSecond[ 3] = 186
    CountsPerSecond[ 4] = 250
    CountsPerSecond[ 5] = 312
    CountsPerSecond[ 6] = 376
    CountsPerSecond[ 7] = 436
    CountsPerSecond[ 8] = 498
    CountsPerSecond[ 9] = 564
    CountsPerSecond[10] = 622
    CountsPerSecond[11] = 682
    CountsPerSecond[12] = 746
    CountsPerSecond[13] = 808
    CountsPerSecond[14] = 874
    CountsPerSecond[15] = 944
    CountsPerSecond[16] = 1004
    CountsPerSecond[17] = 1068
    CountsPerSecond[18] = 1138
    CountsPerSecond[19] = 1208
    CountsPerSecond[20] = 1270
    CountsPerSecond[21] = 1338
    CountsPerSecond[22] = 1408
    CountsPerSecond[23] = 1480
    CountsPerSecond[24] = 1544
    CountsPerSecond[25] = 1622
    CountsPerSecond[26] = 1692
    CountsPerSecond[27] = 1764
    CountsPerSecond[28] = 1846
    CountsPerSecond[29] = 1916
    CountsPerSecond[30] = 2000

    CumulativeCounts[0] = CountsPerSecond[0];
    for kk = 1 to MAX_DAC_VALUE-2
        CumulativeCounts[kk] = CumulativeCounts[kk-1] + CountsPerSecond[kk];
    next kk


    ; initialize timer 1, timer 1 is used as a counter to count the edges from the turntable sensor
    TRISC.0 = 1     ; RC0 is input
    T1GCON = 0      ; disable Timer1 gate control
    T1CON = $84     ; clock source is T1CKI, prescale = 1:1, don't synchronize

    ; use timers 3 and 5 to generate an interrupt about every 1/2 second
    ; Timer 5 rolls over about every 65 milliseconds
    ; Timer 3 counts when timer 5 rolls over.  Timer 3 is set to -8 and interrupts when it rolls
    ; over to 0.  8 * 65 results in interrupts about every 520 milliseconds

    ; initialize timer 5
    T5GCON = 0      ; disable Timer5 gate control
    T5CLK = 1       ; Timer5 clock is Fosc/4
    T5CON = $30     ; prescale = 1:8
    ; timer 5 now counts at Fosc/4/8 = 32/4/8 = 1Mhz, rolls over about every 65 milliseconds

    ; initialize timer 3
    T3GCON = 0      ; disable Timer3 gate control
    T3CLK = $0b     ; Timer3 clock is timer 5 rollover
    T3CON = $00     ; prescale = 1:1

    last_switch_request = $ffff
    desired_tt_position[0] = $ffff
    desired_tt_position[1] = $ffff

    gosub turntable_ee_read_current_location

    ; try to find the current location in the translation table
    for tt_stop = 0 to MAX_TT_STOPS - 1
        gosub turntable_ee_read_stop
        if (tt_ee_switch = $ffff) then 
            tt_stop = MAX_TT_STOPS
            exit
        endif
        if (tt_ee_position[0] = current_tt_loc[0]) and (tt_ee_position[1] = current_tt_loc[1]) then
            exit
        endif
    next tt_stop 
    if  (tt_stop = MAX_TT_STOPS) then
        ; current location not found in translate table
        ; use the first entry in the translate table if it exists
        tt_stop = 0
        gosub turntable_ee_read_stop
    endif
    if tt_ee_switch != $ffff then
        loconet_switch = tt_ee_switch 
        desired_tt_position[0] = tt_ee_position[0]
        desired_tt_position[1] = tt_ee_position[1]
    endif
    last_switch_request = loconet_switch
    return

;=============================================================================

