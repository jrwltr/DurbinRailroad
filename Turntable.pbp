;????don't go past zero, or don't use $ffff as undefined?
;????don't go past 360?
;????fix fine movements with clockwise/counterclockwise keys

;=============================================================================
TT_XOR  var PortA.6
TT_DIR1 var PortC.2
TT_DIR2 var PortB.0

tt_position         var word[2]
current_tt_loc      var word[2]
last_switch_request var word

save_operate_mode   var byte

MAX_TT_STOPS            con 40

;=============================================================================

CURRENT_LOCATION_EEPROM_ADDRESS con 0
    ; the address in EEPROM where the current turntable position is stored
TRANSLATE_TABLE_EEPROM_ADDRESS  con 4 
    ; the address in EEPROM where the turntable translate table is stored

NUM_DAC_VALUES  con 13
DACValues           var byte[NUM_DAC_VALUES]
CountsPerSecond     var word[NUM_DAC_VALUES]
CumulativeCounts    var word[NUM_DAC_VALUES]
DACValIndex         var byte
MaxSpeedIndex       var byte
HoldTimer3Value     var word

RampState           var byte
    RAMP_UP_ONLY    con 0
    RAMP_UP         con 1
    RAMP_HOLD       con 2
    RAMP_DOWN       con 3

;=============================================================================
turntable_set_zero:
    current_tt_loc[0] = 0
    current_tt_loc[1] = 0
turntable_save_current_location:
    ; save location in EEPROM
    ee_address = CURRENT_LOCATION_EEPROM_ADDRESS
    ee_long[0] = current_tt_loc[0]
    ee_long[1] = current_tt_loc[1]
    goto eeprom_write_long

;=============================================================================
Timer1 var word[2]
T var word
read_timer1:
    Timer1[1] = 0
    do
        T.byte0 = TMR1L
        T.byte1 = TMR1H
        if PIR1.0 then
            ;timer overlowed
            Timer1[1] = 1
        endif
        ; if timer ticked while reading, read again
    loop until T.byte0 = TMR1L
    Timer1[0] = T
    return

;=============================================================================
start_timer1:
    ; start timer1 in counter mode
    T1CON.0 = 0     ; T1CON.TMR1ON = 0   disable timer 1
    PIR1.0 = 0      ; PIR1.TMR1IF = 0  turn off timer1 interrupt flag
    TMR1H = 0       ; TMR1H:TMR1L = 0
    TMR1L = 0       ;
    T1CON.0 = 1     ; T1CON.TMR1ON = 1   enable timer 1
    return

;=============================================================================
turntable_stop_timer:
    T5CON.0 = 0 ; T5CON.ON = 0
    T3CON.0 = 0 ; T3CON.ON = 0
    return

;=============================================================================
CounterStop     var word[2]  ; number of counts before stopping timer
Clockwise       var bit

turntable_goto_position:
    if (current_tt_loc[0] = $ffff) and (current_tt_loc[0] = $ffff) then return

    long_minuend[0] = tt_position[0]
    long_minuend[1] = tt_position[1]
    long_subtrahend[0] = current_tt_loc[0]
    long_subtrahend[1] = current_tt_loc[1]
    gosub long_subtract

    if (long_result[0] = 0) and (long_result[1] = 0) then 
        ;tt_position = current_tt_loc
        return
    elseif long_result[1] & $8000 then
        ;tt_position < current_tt_loc

        long_minuend[0] = current_tt_loc[0]
        long_minuend[1] = current_tt_loc[1]
        long_subtrahend[0] = tt_position[0]
        long_subtrahend[1] = tt_position[1]
        gosub long_subtract

        Clockwise = 0
    else
        ;tt_position > current_tt_loc
        Clockwise = 1
    endif
    CounterStop[0] = long_result[0]
    CounterStop[1] = long_result[1]

    for MaxSpeedIndex = NUM_DAC_VALUES-1 to 1 step -1
        long_minuend[0] = CumulativeCounts[MaxSpeedIndex]
        long_minuend[1] = 0
        long_subtrahend[0] = CounterStop[0]
        long_subtrahend[1] = CounterStop[1]
        gosub long_subtract
        ; if CumulativeCounts[MaxSpeedIndex] <= CounterStop then exit
        if long_result[1] & $8000 then exit
    next MaxSpeedIndex

    ; HoldTimer3Value = -int((16 * (CounterStop-CumulativeCounts[MaxSpeedIndex]))/CountsPerSecond[MaxSpeedIndex])
    long_minuend[0] = CounterStop[0]
    long_minuend[1] = CounterStop[1]
    long_subtrahend[0] = CumulativeCounts[MaxSpeedIndex-1]
    long_subtrahend[1] = 0
    gosub long_subtract
    long_multiplicand[0] = long_result[0]
    long_multiplicand[1] = long_result[1]
    long_multiplier = 16
    gosub long_multiply
    long_dividend[0] = long_result[0]
    long_dividend[1] = long_result[1]
    long_divisor[0] = CountsPerSecond[MaxSpeedIndex]
    long_divisor[1] = 0
    gosub long_divide
    HoldTimer3Value = -long_result[0]

    ; start the turntable
    if Clockwise then
        gosub turntable_clockwise
    else
        gosub turntable_counterclockwise
    endif
    
    RampState = RAMP_UP;

    if MaxSpeedIndex != 0 then return
wait_until_done:
    gosub turntable_stop_timer
    long_minuend[0] = CounterStop[0]
    long_minuend[1] = CounterStop[1]
    do
        gosub read_timer1
        long_subtrahend[0] = Timer1[0]
        long_subtrahend[1] = Timer1[1]
        gosub long_subtract
    loop until ((long_result[0] = 0) and (long_result[1] = 0)) or (long_result[1] & $8000)
turntable_stop:
    gosub turntable_stop_timer

    operate_mode = save_operate_mode
    display_update_needed = 1
    if TT_DIR1 = 0 and TT_DIR2 = 0 then return  ; if already stopped return
    TT_DIR1 = 0     ; stop the turntable
    TT_DIR2 = 0     ;
    DAC1CON1 = 0

    pause 600       ; about 600 milliseconds before turntable stops moving at full speed
    T1CON.0 = 0     ; T1CON.TMR1ON = 0   disable timer 1

    gosub read_timer1
    if TT_XOR = 1 then
        ; clockwise, current_tt_loc = current_tt_loc + Timer1
        long_addend1[0] = current_tt_loc[0]
        long_addend1[1] = current_tt_loc[1]
        long_addend2[0] = Timer1[0]
        long_addend2[1] = Timer1[1]
        gosub long_add
    else
        ; counter clockwise, current_tt_loc = current_tt_loc - Timer1
        long_minuend[0] = current_tt_loc[0]
        long_minuend[1] = current_tt_loc[1]
        long_subtrahend[0] = Timer1[0]
        long_subtrahend[1] = Timer1[1]
        gosub long_subtract
    endif
    current_tt_loc[0] = long_result[0]
    current_tt_loc[1] = long_result[1]
    goto turntable_save_current_location

;=============================================================================
turntable_timer_expired:
    ; reset timer 3
    TMR3L = -8
    TMR3H = $ff

    if RampState = RAMP_UP_ONLY then
        if DACValIndex < NUM_DAC_VALUES-1 then
            DACValIndex = DACValIndex + 1
            DAC1CON1 = DACValues[DACValIndex]
        endif
    elseif RampState = RAMP_UP then
        DACValIndex = DACValIndex + 1
        if DACValIndex = MaxSpeedIndex then
            if HoldTimer3Value then
                RampState = RAMP_HOLD;
                TMR3L = HoldTimer3Value.byte0
                TMR3H = HoldTimer3Value.byte1
            else
                RampState = RAMP_DOWN;
            endif
        endif
    elseif RampState = RAMP_HOLD then
        RampState = RAMP_DOWN;
        DACValIndex = DACValIndex - 1
    elseif RampState = RAMP_DOWN then
        if DACValIndex = 1 then
            DAC1CON1 = DACValues[0]
            gosub wait_until_done
            return
        endif
        DACValIndex = DACValIndex - 1
    endif
    DAC1CON1 = DACValues[DACValIndex]
    return

;=============================================================================
turntable_counterclockwise:
    gosub start_timer1
    TT_XOR  = 0
    TT_DIR1 = 0
    TT_DIR2 = 1
    goto turntable_start_dac

turntable_clockwise:
    DACValIndex = 0
    gosub start_timer1
    TT_XOR  = 1
    TT_DIR1 = 1
    TT_DIR2 = 0
turntable_start_dac:
    save_operate_mode = operate_mode
    operate_mode = MODE_MOVING
    gosub update_display
    DACValIndex = 0
    DAC1CON1 = DACValues[1] ; start with DacValues[1] to get things going a bit faster
                            ; this will cause the first two DAC steps to be the same
                            ; speed when ramping up

    ; start turntable timer
    TMR5L = 0       ; TMR5H:TMR5L = 0
    TMR5H = 0
    TMR3L = -8
    TMR3H = $ff
    T5CON.0 = 1 ; T5CON.ON = 1
    T3CON.0 = 1 ; T3CON.ON = 1

    RampState = RAMP_UP_ONLY
    return

;=============================================================================
tt_stop     var word
cl_found    var bit
kk          var byte

look_up_current_location:
    cl_found = 0
    ee_address = TRANSLATE_TABLE_EEPROM_ADDRESS
    for kk = 0 to MAX_TT_STOPS - 1
        gosub eeprom_read_word
        if (ee_word = $ffff) then exit
        ee_address = ee_address + 2
        gosub eeprom_read_long
        ee_address = ee_address + 4
        if (ee_long[0] = current_tt_loc[0]) and (ee_long[1] = current_tt_loc[1]) then
            cl_found = 1
            loconet_switch = ee_word
            tt_position[0] = ee_long[0]
            tt_position[1] = ee_long[1]
            exit
        endif
    next kk 
    return

;=============================================================================
turntable_next_location:
    if (loconet_switch = $ffff) or (tt_stop = MAX_TT_STOPS - 1) then return
    ee_address = TRANSLATE_TABLE_EEPROM_ADDRESS + ((tt_stop + 1) * 6)
    gosub eeprom_read_word
    if ee_word != $ffff then
        tt_stop = tt_stop + 1
        loconet_switch = ee_word
        last_switch_request = ee_word
        ee_address = ee_address + 2
        gosub eeprom_read_long
        tt_position[0] = ee_long[0]
        tt_position[1] = ee_long[1]
    endif
    return

;=============================================================================
turntable_previous_location:
    if (loconet_switch = $ffff) or (tt_stop = 0) then return
    ee_address = TRANSLATE_TABLE_EEPROM_ADDRESS + ((tt_stop-1) * 6)
    gosub eeprom_read_word
    if ee_word != $ffff then
        tt_stop = tt_stop - 1
        loconet_switch = ee_word
        last_switch_request = ee_word
        ee_address = ee_address + 2
        gosub eeprom_read_long
        tt_position[0] = ee_long[0]
        tt_position[1] = ee_long[1]
    endif
    return

;=============================================================================
look_up_loconet_switch:
    ee_address = TRANSLATE_TABLE_EEPROM_ADDRESS
    for kk = 0 to MAX_TT_STOPS - 1
        gosub eeprom_read_word
        if (ee_word = $ffff) then exit
        ee_address = ee_address + 2
        if (ee_word = loconet_switch) then exit
        ee_address = ee_address + 4
    next kk
    return

;=============================================================================
handle_switch_request:
    gosub look_up_loconet_switch
    if (ee_word = loconet_switch) then
        gosub eeprom_read_long
        tt_position[0] = ee_long[0]
        tt_position[1] = ee_long[1]
        ; loconet_switch found in translate table
        last_switch_request = loconet_switch
        tt_stop = kk
        if operate_mode = MODE_PROGRAM then return
    else
        ; loconet_switch not found in translate table
        if operate_mode = MODE_OPERATE then 
            loconet_switch = last_switch_request
        else
            tt_position[0] = $ffff
            tt_position[1] = $ffff
        endif
        return
    endif

    goto turntable_goto_position

;=============================================================================
turntable_set_translation:
    if (loconet_switch = $ffff) or ((current_tt_loc[0] = $ffff) and (current_tt_loc[1] = $ffff)) then return
    gosub look_up_loconet_switch
    if kk = MAX_TT_STOPS then 
        ; EEPROM is full
        return
    endif
    tt_stop = kk
    if loconet_switch != ee_word then
        ee_address = TRANSLATE_TABLE_EEPROM_ADDRESS + (tt_stop * 6)
        ee_word = loconet_switch
        gosub eeprom_write_word
    endif
    ee_address = TRANSLATE_TABLE_EEPROM_ADDRESS + (tt_stop * 6) + 2
    ee_long[0] = current_tt_loc[0]
    ee_long[1] = current_tt_loc[1]
    gosub eeprom_write_long
    tt_position[0] = current_tt_loc[0]
    tt_position[1] = current_tt_loc[1]
    return

;=============================================================================
turntable_initialize:
    TT_DIR1 = 0
    TT_DIR2 = 0
    DAC1CON1 = 0
    DAC1CON0 = 0
    DAC1CON0.4 = 1   ; DAC1CON0.DACOE2 = 0    DAC is output to DACOUT2 pin
    DAC1CON0.7 = 1   ; DAC1CON0.DACEN = 1     enable DAC 

    ARRAYWRITE DACValues,       [  1,   3,   5,   7,   9,  11,  14,  17,   20,   23,   26,   29,   31 ]
    CountsPerSecond[0] = 105
    CountsPerSecond[1] = 174
    CountsPerSecond[2] = 292
    CountsPerSecond[3] = 400
    CountsPerSecond[4] = 536
    CountsPerSecond[5] = 660
    CountsPerSecond[6] = 841
    CountsPerSecond[7] = 1034
    CountsPerSecond[8] = 1243
    CountsPerSecond[9] = 1452
    CountsPerSecond[10] = 1601
    CountsPerSecond[11] = 1856
    CountsPerSecond[12] = 2000

    CumulativeCounts[0] = CountsPerSecond[0];
    for kk = 1 to NUM_DAC_VALUES-1
        CumulativeCounts[kk] = CumulativeCounts[kk-1] + CountsPerSecond[kk];
    next kk


    ; initialize timer 1, timer 1 is used as a counter to count the edges from the turntable sensor
    TRISC.0 = 1     ; RC0 is input
    T1GCON = 0      ; disable Timer1 gate control
    T1CON = $84     ; clock source is T1CKI, prescale = 1:1, don't synchronize

    ; use timers 3 and 5 to generate an interrupt about every 1/2 second
    ; Timer 5 rolls over about every 65 milliseconds
    ; Timer 3 counts when timer 5 rolls over.  Timer 3 is set to -8 and interrupts when it rolls
    ; over to 0.  8 * 65 results in interrupts about every 520 milliseconds

    ; initialize timer 5
    T5GCON = 0      ; disable Timer5 gate control
    T5CLK = 1       ; Timer5 clock is Fosc/4
    T5CON = $30     ; prescale = 1:8
    ; timer 5 now counts at Fosc/4/8 = 32/4/8 = 1Mhz, rolls over about every 65 milliseconds

    ; initialize timer 3
    T3GCON = 0      ; disable Timer3 gate control
    T3CLK = $0b     ; Timer3 clock is timer 5 rollover
    T3CON = $00     ; prescale = 1:1

    last_switch_request = $ffff
    tt_position[0] = $ffff
    tt_position[1] = $ffff

    ee_address = CURRENT_LOCATION_EEPROM_ADDRESS
    gosub eeprom_read_long
    current_tt_loc[0] = ee_long[0]
    current_tt_loc[1] = ee_long[1]

    gosub look_up_current_location
    tt_stop = kk
    if !cl_found then
        tt_stop = 0
        ee_address = TRANSLATE_TABLE_EEPROM_ADDRESS
        gosub eeprom_read_word
        if ee_word != $ffff then
            loconet_switch = ee_word
            ee_address = ee_address + 2
            gosub eeprom_read_long
            tt_position[0] = ee_long[0]
            tt_position[1] = ee_long[1]
        endif
    endif
    last_switch_request = loconet_switch
    return

;=============================================================================

