;=============================================================================
; This code manipulates banks of switch motors.  A bank is a collection of 
; 5 switch motors connected via one PCF8574 and one PCF8574A.
;=============================================================================

;=============================================================================
interface_debounce    var byte[I2C_INTERFACE_COUNT]

;=============================================================================
i2c_addr        var byte

;=============================================================================
#ifdef DO_SWITCH_CONTROLLER
switch_bank_write_from_eeprom:
    gosub switch_eeprom_read_bank
    switch_bank_value = ee_word
#ifdef DO_RS485
    if switch_address != my_address then
        goto rs485_send_bank_write_request
    endif
#endif
    goto switch_bank_write
#endif

;=============================================================================
bval var byte
switch_bank_write:
    i2c_addr = (switch_bank // BANKS_PER_INTERFACE) << 1
    if (switch_bank / BANKS_PER_INTERFACE) = 0 then
        bval = switch_bank_value & $ff
        i2c_addr = i2c_addr + PCF8574_I2C_ADDRESS 
        I2CWRITE SW0_INTERFACE_I2C_DATA, SW0_INTERFACE_I2C_CLK, i2c_addr, [ bval ], i2c_write_error
        pause 10
        bval = ((switch_bank_value >> 8) & $3) | $fc
        i2c_addr = i2c_addr - PCF8574_I2C_ADDRESS + PCF8574A_I2C_ADDRESS 
        I2CWRITE SW0_INTERFACE_I2C_DATA, SW0_INTERFACE_I2C_CLK, i2c_addr, [ bval ], i2c_write_error
        pause 10
#ifndef DO_DEVELOPMENT_BOARD
    else
        bval = switch_bank_value & $ff
        i2c_addr = i2c_addr + PCF8574_I2C_ADDRESS 
        I2CWRITE SW1_INTERFACE_I2C_DATA, SW1_INTERFACE_I2C_CLK, i2c_addr, [ bval ], i2c_write_error
        pause 10
        bval = ((switch_bank_value >> 8) & $3) | $fc
        i2c_addr = i2c_addr - PCF8574_I2C_ADDRESS + PCF8574A_I2C_ADDRESS 
        I2CWRITE SW1_INTERFACE_I2C_DATA, SW1_INTERFACE_I2C_CLK, i2c_addr, [ bval ], i2c_write_error
        pause 10
#endif
    endif
i2c_write_error:
    return

;=============================================================================
#ifdef DO_SWITCH_CONTROLLER
k   var byte
handle_switch_request:
    gosub switch_eeprom_find_translation
    
    if (operate_mode = MODE_ROUTE_EDIT) then
        if (!switch_not_defined) then
            route_to_find = loconet_switch
            gosub route_eeprom_find
            if (route_found != ROUTE_NOT_FOUND) then
                ARRAYWRITE DisplayString, ["Switch is route", 0]
            else
                ARRAYWRITE DisplayString, ["Switch undefined", 0]
            endif
            goto route_error
        else
            ;find loconet_switch in current route
            route_switch_index = $ff
            if route_num_switches != 0 then
                for k = 0 to (route_num_switches-1)
                    if (route_switches[k] & $7fff) = loconet_switch then
                        route_switch_index = k
                        exit
                    endif
                next k
            else
                k = 0
            endif

            if (route_switch_index = $ff) then
                ; loconet_switch not found in current route, add switch to route
                if route_num_switches >= MAX_ROUTE_SWITCHES then 
                    ARRAYWRITE DisplayString, ["Too many switches", 0]
                    goto route_error
                endif
                route_switch_index = route_num_switches
                route_num_switches = route_num_switches + 1
            endif
            if switch_motor_direction = SWITCH_MOTOR_THROWN then
                route_switches[route_switch_index] = loconet_switch | $8000
            else
                route_switches[route_switch_index] = loconet_switch
            endif
        endif
    else
        if (switch_not_defined) then
            route_to_find = loconet_switch
            gosub route_eeprom_find
            if route_found != ROUTE_NOT_FOUND then
                route_number = loconet_switch
                gosub route_eeprom_read
                if operate_mode = MODE_OPERATE then
                    gosub route_activate
                endif
            else
                route_number = ROUTE_NOT_FOUND
            endif
        else
            route_number = ROUTE_NOT_FOUND
            if operate_mode = MODE_OPERATE then
                switch_motor_state = switch_motor_direction
                gosub switch_eeprom_write_switch_state
                gosub switch_bank_write_from_eeprom
             endif
        endif
    endif
    return
#endif

;=============================================================================
interface_index var byte
switch_index    var byte
bank_index      var byte
debounce        var byte
i2c_read_value  var byte    ; last value read from I2C

switch_motor_button_check:
    for interface_index = 0 to I2C_INTERFACE_COUNT-1
        debounce = interface_debounce[interface_index] << 1
        if     ((interface_index = 0) && (SWITCH_MOTOR_INTERFACE0_INTERRUPT = 0)) then 
            debounce = debounce | 1
#ifndef DO_DEVELOPMENT_BOARD
        elseif ((interface_index = 1) && (SWITCH_MOTOR_INTERFACE1_INTERRUPT = 0)) then
            debounce = debounce | 1
#endif
        endif
        interface_debounce[interface_index] = debounce
        if debounce = $3f then
            ; for each PCF8574 with buttons attached...
            for bank_index = 0 to BANKS_PER_INTERFACE-1
                i2c_addr = PCF8574A_I2C_ADDRESS + (bank_index << 1)
                if interface_index = 0 then
                    I2CREAD SW0_INTERFACE_I2C_DATA, SW0_INTERFACE_I2C_CLK, i2c_addr, [ i2c_read_value ], i2c_read_error
#ifndef DO_DEVELOPMENT_BOARD
                elseif interface_index = 1 then
                    I2CREAD SW1_INTERFACE_I2C_DATA, SW1_INTERFACE_I2C_CLK, i2c_addr, [ i2c_read_value ], i2c_read_error
#endif
                endif
                i2c_read_value = ~i2c_read_value
#ifdef DO_SWITCH_EXTENSION
                ; if any button is pushed
                switch_bank_value = (i2c_read_value >> 3) & $1f
                if switch_bank_value then
                    led_to_change = LED_SWITCHMOTOR_BUTTON
                    gosub led_flash
                    ; if any button changed state
                    switch_bank = (interface_index * BANKS_PER_INTERFACE) + bank_index
                    if last_motor_bank_state[switch_bank] != switch_bank_value then
                        gosub rs485_send_bank_button_state
                    endif
                endif
                last_motor_bank_state[switch_bank] = switch_bank_value 
#else
                for switch_index = 0 to SWITCH_MOTORS_PER_BANK-1
                    sm  var byte
                    sm = (((interface_index * BANKS_PER_INTERFACE) + bank_index) * SWITCH_MOTORS_PER_BANK) + switch_index
                    ; if the button is pushed
                    if i2c_read_value & ($8 << switch_index) then
                        ; if the button changed state...
                        if last_motor_button_state[sm] = 0 then
#ifdef DO_DISPLAY
                            display_update_needed = 1
#endif
#ifdef DO_DEVELOPEMENT_BOARD
                            led_to_change = LED_SWITCHMOTOR_BUTTON
                            gosub led_flash
#endif
#ifdef DO_SWITCH_CONTROLLER
                            switch_not_defined = 0
#endif
                            switch_motor = switch_index
                            switch_bank = (interface_index * BANKS_PER_INTERFACE) + bank_index
                            switch_address = my_address
#ifdef DO_OPERATE_PROGRAM
                            if operate_mode == MODE_OPERATE then
                                switch_motor_state = SWITCH_MOTOR_TOGGLE
                                gosub switch_eeprom_write_switch_state
                                gosub switch_bank_write_from_eeprom
                            elseif operate_mode == MODE_PROGRAM then
                                if loconet_switch != $ffff then
                                    if route_number != ROUTE_NOT_FOUND then
                                        route_number = loconet_switch
                                        gosub route_eeprom_delete
                                    endif
                                    gosub switch_eeprom_write_translation
                                endif
                            endif
#endif
#ifdef DO_SWITCH_CONTROLLER
#ifdef DO_LOCONET
                            gosub switch_eeprom_find_reverse_translation
#endif
                            route_number = ROUTE_NOT_FOUND
#endif
                        endif
                        last_motor_button_state[sm] = 1
                    else
                        last_motor_button_state[sm] = 0
                    endif
                next switch_index
#endif
i2c_read_error:
            next bank_index
        endif
    next interface_index
    return

;=============================================================================
#ifdef DO_SWITCH_CONTROLLER
handle_remote_button_press:
    return
#endif

;=============================================================================
switch_motor_initialize:
#ifdef DO_SWITCH_CONTROLLER
    my_address = LOCAL_ADDRESS

    ;write all the switch motor controls to match the values read from eeprom
    gosub switch_eeprom_initialize

    gosub route_initialize
    switch_not_defined = 1
#else
    ;read my_address from address switches
    my_address =              (EXT_ADDR3 << 3)
    my_address = my_address + (EXT_ADDR2 << 2)
    my_address = my_address + (EXT_ADDR1 << 1)
    my_address = my_address +  EXT_ADDR0
#endif
    return

;=============================================================================


